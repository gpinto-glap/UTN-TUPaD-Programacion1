# -*- coding: utf-8 -*-
"""TP 9 Recursividad

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-dS5zgoc6JV76OHk1PogPqsYHUCxpm_T
"""

#Ejercicio 1
#Crea una función recursiva que calcule el factorial de un número. Luego, utiliza esa
#función para calcular y mostrar en pantalla el factorial de todos los números enteros
#entre 1 y el número que indique el usuario

def factorial_recursivo(num):
  if num==0:
    return 1
  else:
    return num * factorial_recursivo(num-1)

def mostrar_factorial():
  numero_ingresado= int(input("Ingrese un numero entero: "))
  for i in range(numero_ingresado+1):
    resultado=factorial_recursivo(i)
    print (f"el factorial del número {i} es: {resultado}")

mostrar_factorial()

#Ejercicio 2
#Crea una función recursiva que calcule el valor de la serie de Fibonacci en la posición
#indicada. Posteriormente, muestra la serie completa hasta la posición que el usuario especifique.
def fibonacci_recursivo(n):
    if n <= 1:
       return n
    else:

        return fibonacci_recursivo(n-1) + fibonacci_recursivo(n-2)

def mostrar_serie_fibonacci(posicion_buscada):
    if posicion_buscada < 0:
        print("La posición límite debe ser un número entero no negativo.")
        return

    print(f"\n Serie de Fibonacci hasta la posición {posicion_buscada}:")
    serie = []
    for i in range(posicion_buscada + 1):
        valor = fibonacci_recursivo(i)
        serie.append(valor)

    print(serie)
    print(f"El valor en la posición {posicion_buscada} es: {fibonacci_recursivo(posicion_buscada)}")

posicion = int(input("Ingresa la posición máxima (un número entero no negativo) para la serie de Fibonacci: "))
mostrar_serie_fibonacci(posicion)

#Ejercicio 3

def potencia_recursiva(base, exponente):
    if exponente == 0:
        return 1

    if exponente == 1:
        return base

    if exponente > 1:

        return base * potencia_recursiva(base, exponente - 1)

    if exponente < 0:
        # n**(-m) = 1 / n**m. Llama a la función para el exponente positivo
        return 1 / potencia_recursiva(base, abs(exponente))



def probar_potencia():
    base_input = input("Ingresa la BASE (n): ")
    exponente_input = input("Ingresa el EXPONENTE (m): ")


    if '.' in base_input:
         base = float(base_input)
    else:
         base = int(base_input)
         exponente = int(exponente_input)

    if base == 0 and exponente == 0:
        resultado = 1

    elif base == 0 and exponente < 0:
        print(f"\n La potencia {base}**{exponente} es una división por cero (Indefinido).")
        return

    else:
        resultado = potencia_recursiva(base, exponente)


    print(f"\n Resultado:")
    print(f"   {base} elevado a la {exponente} ({base}**{exponente}) es: **{resultado}**")
    print("-" * 35)

# Ejecutar el algoritmo de prueba
probar_potencia()

#Ejercicio 4
def decimal_a_binario_recursivo(decimal):
    if decimal == 0:
        return "0"

    if decimal == 1:
        return "1"

    resto = decimal % 2
    cociente = decimal // 2

    return decimal_a_binario_recursivo(cociente) + str(resto)



def probar_conversion():
    numero_decimal = int(input("Ingresa un número entero positivo: "))

    if numero_decimal < 0:
        print("\n Advertencia: La función está diseñada para enteros positivos. Usaremos su valor absoluto.")
        numero_decimal = abs(numero_decimal)

    if numero_decimal == 0:
         resultado_binario = "0"
    else:

        resultado_binario = decimal_a_binario_recursivo(numero_decimal)


    print(f"\n Resultado de la conversión:")
    print(f"   Decimal: {numero_decimal}")
    print(f"   Binario: **{resultado_binario}**")
    print("-" * 39)


probar_conversion()

#Ejercicio 5
def es_palindromo(palabra):

    if len(palabra) <= 1:
        return True

    if palabra[0] == palabra[-1]:
        return es_palindromo(palabra[1:-1])
    else:
        return False

# --- Bloque de Prueba ---

print(" Pruebas de Palíndromo Recursivo:")
print("-" * 40)

# Palíndromos
print(f"¿'gallina' es palíndromo? {es_palindromo('gallina')}")       # False
print(f"¿'reconocer' es palíndromo? {es_palindromo('reconocer')}")   # True
print(f"¿'oso' es palíndromo? {es_palindromo('oso')}")               # True
print(f"¿'a' es palíndromo? {es_palindromo('a')}")                   # True
print(f"¿'' es palíndromo? {es_palindromo('')}")                     # True
print(f"¿'abba' es palíndromo? {es_palindromo('abba')}")             # True

# No Palíndromos
print(f"¿'python' es palíndromo? {es_palindromo('python')}")         # False
print(f"¿'casa' es palíndromo? {es_palindromo('casa')}")             # False
print("-" * 40)

#Ejercicio 6
def suma_digitos(n):

    # Si el número tiene un solo dígito (es menor que 10), la suma es el número mismo.
    if n < 10:
        return n

    # --- Paso Recursivo ---

    ultimo_digito = n % 10
    resto_del_numero = n // 10

    return ultimo_digito + suma_digitos(resto_del_numero)


# Ejemplos del enunciado
resultado1 = suma_digitos(1234)
print(f"Suma de dígitos de 1234: {resultado1} (1 + 2 + 3 + 4)")

resultado2 = suma_digitos(9)
print(f"Suma de dígitos de 9:    {resultado2}")

resultado3 = suma_digitos(305)
print(f"Suma de dígitos de 305:  {resultado3} (3 + 0 + 5)")

# Ejemplo adicional
resultado4 = suma_digitos(8675309)
print(f"Suma de dígitos de 8675309: {resultado4} (8+6+7+5+3+0+9 = 38)")
print("-" * 45)

#Ejercicio 7
def contar_bloques(n):
   if n == 1:
        return 1

   return n + contar_bloques(n - 1)

# ---  Prueba ---
# Ejemplos del enunciado
resultado1 = contar_bloques(1)
print(f"Bloques para base 1: {resultado1} (1)")

resultado2 = contar_bloques(2)
print(f"Bloques para base 2: {resultado2} (2 + 1)")

resultado3 = contar_bloques(4)
print(f"Bloques para base 4: {resultado3} (4 + 3 + 2 + 1)")

# Ejemplo adicional
resultado4 = contar_bloques(5)
print(f"Bloques para base 5: {resultado4} (5 + 4 + 3 + 2 + 1 = 15)")
print("-" * 50)

#Ejercicio 8
def contar_digito(numero, digito):
    if numero == 0:
        return 0

    # --- Paso Recursivo ---
    ultimo_digito = numero % 10
    match = 0
    if ultimo_digito == digito:
        match = 1

    resto_del_numero = numero // 10

    return match + contar_digito(resto_del_numero, digito)

# --- Prueba ---


# Ejemplos del enunciado
print(f"Número: 12233421, Dígito: 2 -> Resultado: {contar_digito(12233421, 2)}")
print(f"Número: 5555, Dígito: 5    -> Resultado: {contar_digito(5555, 5)}")
print(f"Número: 123456, Dígito: 7  -> Resultado: {contar_digito(123456, 7)}")

# Ejemplo con el dígito 0
print(f"Número: 102030, Dígito: 0  -> Resultado: {contar_digito(102030, 0)}")

# Ejemplo con un solo dígito
print(f"Número: 8, Dígito: 8      -> Resultado: {contar_digito(8, 8)}")
print("-" * 45)